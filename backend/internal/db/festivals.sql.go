// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: festivals.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createFestival = `-- name: CreateFestival :one
INSERT INTO festivals (
    slug, name, date_type, usual_month, date_2026_start, date_2026_end,
    region, heritage_type, festival_type, summary, story, what_to_expect,
    how_to_participate, practical_info, cover_image_url, gallery_images,
    video_embeds, is_published
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18
) RETURNING id, slug, name, date_type, usual_month, date_2026_start, date_2026_end, region, heritage_type, festival_type, summary, story, what_to_expect, how_to_participate, practical_info, cover_image_url, gallery_images, video_embeds, is_published, created_at
`

type CreateFestivalParams struct {
	Slug             string      `json:"slug"`
	Name             string      `json:"name"`
	DateType         string      `json:"date_type"`
	UsualMonth       pgtype.Text `json:"usual_month"`
	Date2026Start    pgtype.Date `json:"date_2026_start"`
	Date2026End      pgtype.Date `json:"date_2026_end"`
	Region           string      `json:"region"`
	HeritageType     string      `json:"heritage_type"`
	FestivalType     string      `json:"festival_type"`
	Summary          string      `json:"summary"`
	Story            pgtype.Text `json:"story"`
	WhatToExpect     pgtype.Text `json:"what_to_expect"`
	HowToParticipate pgtype.Text `json:"how_to_participate"`
	PracticalInfo    pgtype.Text `json:"practical_info"`
	CoverImageUrl    pgtype.Text `json:"cover_image_url"`
	GalleryImages    []byte      `json:"gallery_images"`
	VideoEmbeds      []byte      `json:"video_embeds"`
	IsPublished      pgtype.Bool `json:"is_published"`
}

func (q *Queries) CreateFestival(ctx context.Context, arg CreateFestivalParams) (Festival, error) {
	row := q.db.QueryRow(ctx, createFestival,
		arg.Slug,
		arg.Name,
		arg.DateType,
		arg.UsualMonth,
		arg.Date2026Start,
		arg.Date2026End,
		arg.Region,
		arg.HeritageType,
		arg.FestivalType,
		arg.Summary,
		arg.Story,
		arg.WhatToExpect,
		arg.HowToParticipate,
		arg.PracticalInfo,
		arg.CoverImageUrl,
		arg.GalleryImages,
		arg.VideoEmbeds,
		arg.IsPublished,
	)
	var i Festival
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Name,
		&i.DateType,
		&i.UsualMonth,
		&i.Date2026Start,
		&i.Date2026End,
		&i.Region,
		&i.HeritageType,
		&i.FestivalType,
		&i.Summary,
		&i.Story,
		&i.WhatToExpect,
		&i.HowToParticipate,
		&i.PracticalInfo,
		&i.CoverImageUrl,
		&i.GalleryImages,
		&i.VideoEmbeds,
		&i.IsPublished,
		&i.CreatedAt,
	)
	return i, err
}

const getFestivalByID = `-- name: GetFestivalByID :one
SELECT id, slug, name, date_type, usual_month, date_2026_start, date_2026_end, region, heritage_type, festival_type, summary, story, what_to_expect, how_to_participate, practical_info, cover_image_url, gallery_images, video_embeds, is_published, created_at FROM festivals
WHERE id = $1
`

func (q *Queries) GetFestivalByID(ctx context.Context, id pgtype.UUID) (Festival, error) {
	row := q.db.QueryRow(ctx, getFestivalByID, id)
	var i Festival
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Name,
		&i.DateType,
		&i.UsualMonth,
		&i.Date2026Start,
		&i.Date2026End,
		&i.Region,
		&i.HeritageType,
		&i.FestivalType,
		&i.Summary,
		&i.Story,
		&i.WhatToExpect,
		&i.HowToParticipate,
		&i.PracticalInfo,
		&i.CoverImageUrl,
		&i.GalleryImages,
		&i.VideoEmbeds,
		&i.IsPublished,
		&i.CreatedAt,
	)
	return i, err
}

const getFestivalBySlug = `-- name: GetFestivalBySlug :one
SELECT id, slug, name, date_type, usual_month, date_2026_start, date_2026_end, region, heritage_type, festival_type, summary, story, what_to_expect, how_to_participate, practical_info, cover_image_url, gallery_images, video_embeds, is_published, created_at FROM festivals
WHERE slug = $1 AND is_published = true
`

func (q *Queries) GetFestivalBySlug(ctx context.Context, slug string) (Festival, error) {
	row := q.db.QueryRow(ctx, getFestivalBySlug, slug)
	var i Festival
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Name,
		&i.DateType,
		&i.UsualMonth,
		&i.Date2026Start,
		&i.Date2026End,
		&i.Region,
		&i.HeritageType,
		&i.FestivalType,
		&i.Summary,
		&i.Story,
		&i.WhatToExpect,
		&i.HowToParticipate,
		&i.PracticalInfo,
		&i.CoverImageUrl,
		&i.GalleryImages,
		&i.VideoEmbeds,
		&i.IsPublished,
		&i.CreatedAt,
	)
	return i, err
}

const listFestivals = `-- name: ListFestivals :many
SELECT id, slug, name, date_type, usual_month, date_2026_start, date_2026_end, region, heritage_type, festival_type, summary, story, what_to_expect, how_to_participate, practical_info, cover_image_url, gallery_images, video_embeds, is_published, created_at FROM festivals
WHERE is_published = true
ORDER BY date_2026_start ASC NULLS LAST
`

func (q *Queries) ListFestivals(ctx context.Context) ([]Festival, error) {
	rows, err := q.db.Query(ctx, listFestivals)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Festival{}
	for rows.Next() {
		var i Festival
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Name,
			&i.DateType,
			&i.UsualMonth,
			&i.Date2026Start,
			&i.Date2026End,
			&i.Region,
			&i.HeritageType,
			&i.FestivalType,
			&i.Summary,
			&i.Story,
			&i.WhatToExpect,
			&i.HowToParticipate,
			&i.PracticalInfo,
			&i.CoverImageUrl,
			&i.GalleryImages,
			&i.VideoEmbeds,
			&i.IsPublished,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFestivalsByHeritage = `-- name: ListFestivalsByHeritage :many
SELECT id, slug, name, date_type, usual_month, date_2026_start, date_2026_end, region, heritage_type, festival_type, summary, story, what_to_expect, how_to_participate, practical_info, cover_image_url, gallery_images, video_embeds, is_published, created_at FROM festivals
WHERE is_published = true AND heritage_type = $1
ORDER BY date_2026_start ASC NULLS LAST
`

func (q *Queries) ListFestivalsByHeritage(ctx context.Context, heritageType string) ([]Festival, error) {
	rows, err := q.db.Query(ctx, listFestivalsByHeritage, heritageType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Festival{}
	for rows.Next() {
		var i Festival
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Name,
			&i.DateType,
			&i.UsualMonth,
			&i.Date2026Start,
			&i.Date2026End,
			&i.Region,
			&i.HeritageType,
			&i.FestivalType,
			&i.Summary,
			&i.Story,
			&i.WhatToExpect,
			&i.HowToParticipate,
			&i.PracticalInfo,
			&i.CoverImageUrl,
			&i.GalleryImages,
			&i.VideoEmbeds,
			&i.IsPublished,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFestivalsByRegion = `-- name: ListFestivalsByRegion :many
SELECT id, slug, name, date_type, usual_month, date_2026_start, date_2026_end, region, heritage_type, festival_type, summary, story, what_to_expect, how_to_participate, practical_info, cover_image_url, gallery_images, video_embeds, is_published, created_at FROM festivals
WHERE is_published = true AND region = $1
ORDER BY date_2026_start ASC NULLS LAST
`

func (q *Queries) ListFestivalsByRegion(ctx context.Context, region string) ([]Festival, error) {
	rows, err := q.db.Query(ctx, listFestivalsByRegion, region)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Festival{}
	for rows.Next() {
		var i Festival
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Name,
			&i.DateType,
			&i.UsualMonth,
			&i.Date2026Start,
			&i.Date2026End,
			&i.Region,
			&i.HeritageType,
			&i.FestivalType,
			&i.Summary,
			&i.Story,
			&i.WhatToExpect,
			&i.HowToParticipate,
			&i.PracticalInfo,
			&i.CoverImageUrl,
			&i.GalleryImages,
			&i.VideoEmbeds,
			&i.IsPublished,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUpcomingFestivals = `-- name: ListUpcomingFestivals :many
SELECT id, slug, name, date_type, usual_month, date_2026_start, date_2026_end, region, heritage_type, festival_type, summary, story, what_to_expect, how_to_participate, practical_info, cover_image_url, gallery_images, video_embeds, is_published, created_at FROM festivals
WHERE is_published = true
  AND date_2026_start >= CURRENT_DATE
  AND date_2026_start <= CURRENT_DATE + INTERVAL '30 days'
ORDER BY date_2026_start ASC
`

func (q *Queries) ListUpcomingFestivals(ctx context.Context) ([]Festival, error) {
	rows, err := q.db.Query(ctx, listUpcomingFestivals)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Festival{}
	for rows.Next() {
		var i Festival
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Name,
			&i.DateType,
			&i.UsualMonth,
			&i.Date2026Start,
			&i.Date2026End,
			&i.Region,
			&i.HeritageType,
			&i.FestivalType,
			&i.Summary,
			&i.Story,
			&i.WhatToExpect,
			&i.HowToParticipate,
			&i.PracticalInfo,
			&i.CoverImageUrl,
			&i.GalleryImages,
			&i.VideoEmbeds,
			&i.IsPublished,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
