// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: memories.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createMemory = `-- name: CreateMemory :one
INSERT INTO memories (
    festival_id, author_name, author_email, content, year_of_memory
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, festival_id, author_name, author_email, content, year_of_memory, status, submitted_at
`

type CreateMemoryParams struct {
	FestivalID   pgtype.UUID `json:"festival_id"`
	AuthorName   pgtype.Text `json:"author_name"`
	AuthorEmail  pgtype.Text `json:"author_email"`
	Content      string      `json:"content"`
	YearOfMemory pgtype.Text `json:"year_of_memory"`
}

func (q *Queries) CreateMemory(ctx context.Context, arg CreateMemoryParams) (Memory, error) {
	row := q.db.QueryRow(ctx, createMemory,
		arg.FestivalID,
		arg.AuthorName,
		arg.AuthorEmail,
		arg.Content,
		arg.YearOfMemory,
	)
	var i Memory
	err := row.Scan(
		&i.ID,
		&i.FestivalID,
		&i.AuthorName,
		&i.AuthorEmail,
		&i.Content,
		&i.YearOfMemory,
		&i.Status,
		&i.SubmittedAt,
	)
	return i, err
}

const getMemoryByID = `-- name: GetMemoryByID :one
SELECT id, festival_id, author_name, author_email, content, year_of_memory, status, submitted_at FROM memories
WHERE id = $1
`

func (q *Queries) GetMemoryByID(ctx context.Context, id pgtype.UUID) (Memory, error) {
	row := q.db.QueryRow(ctx, getMemoryByID, id)
	var i Memory
	err := row.Scan(
		&i.ID,
		&i.FestivalID,
		&i.AuthorName,
		&i.AuthorEmail,
		&i.Content,
		&i.YearOfMemory,
		&i.Status,
		&i.SubmittedAt,
	)
	return i, err
}

const listMemoriesByFestival = `-- name: ListMemoriesByFestival :many
SELECT id, festival_id, author_name, author_email, content, year_of_memory, status, submitted_at FROM memories
WHERE festival_id = $1 AND status = 'approved'
ORDER BY submitted_at DESC
`

func (q *Queries) ListMemoriesByFestival(ctx context.Context, festivalID pgtype.UUID) ([]Memory, error) {
	rows, err := q.db.Query(ctx, listMemoriesByFestival, festivalID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Memory{}
	for rows.Next() {
		var i Memory
		if err := rows.Scan(
			&i.ID,
			&i.FestivalID,
			&i.AuthorName,
			&i.AuthorEmail,
			&i.Content,
			&i.YearOfMemory,
			&i.Status,
			&i.SubmittedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMemoryStatus = `-- name: UpdateMemoryStatus :exec
UPDATE memories
SET status = $2
WHERE id = $1
`

type UpdateMemoryStatusParams struct {
	ID     pgtype.UUID `json:"id"`
	Status pgtype.Text `json:"status"`
}

func (q *Queries) UpdateMemoryStatus(ctx context.Context, arg UpdateMemoryStatusParams) error {
	_, err := q.db.Exec(ctx, updateMemoryStatus, arg.ID, arg.Status)
	return err
}
